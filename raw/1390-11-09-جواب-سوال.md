---
blog:
    author: شااززز منگولیا
    date: [1390, 11, 9, 20, 20]
---
# جواب سوال

<div class="cnt">
<p align="right" class="" dir="ltr">سلام</p>
<p align="right" class="" dir="ltr">جواب سوال های
الگوریتمی که هفته ی پیش گذاشتیم آماده کردیم. اگه سوالی رو حل نکردید بعد از این
که راه حلش رو خوندید سعی کنید خودتون کدش رو بزنید و بعد کد ما رو بخونید.</p>
<p class="" dir="ltr"><br/></p>
<p class="" dir="rtl">1- در واقع برای حل این سوال اگر عدد حاج سعید یکی از مقسوم علیه های
عدد پویا باشد، پویا برنده است و در غیر این صورت حاج سعید. حال اگرd(x) را مساوی تعداد مقسوم علیه هایxتعریف کنیم ، بنابراین جواب مساله می شود.d(n)/10^9پس در واقع الان بایدd(n)را درO(sqrt(n))حساب کنیم . برای این فرض
کنیدn=a*b که(a<b></b>در این صورتaاست
(چرا؟).پس اگر ما مقسوم علیه های کوچکتر از n را در ((O(sqrt(n حساب کنیم. سایر مقسوم علیه ها هم پیدا می شوند.</p>
<p class="" dir="rtl"><a href="http://paste.ubuntu.com/821687/">کد سوال</a><br/></p>
<p><u><br/></u></p>
<p class="" dir="ltr"></p>
<p class="" dir="rtl">     
2- برای حل این سوال از برنامه ریزی پویا استفاده می کنیم.</p>
<p class="" dir="rtl">Win[i][j][k]: بازی را کهi دسته ی سمت چپ تا حالا دست نخورده
باشند و سپس یک دسته باjسنگریزه
داشته باشد و بعد از آن یک دسته باkسنگریزه
در نظر بگیرید. حالWin[i][j][k]یک است اگر نفر
اول ببرد و در غیر این صورت صفر است.</p>
<p class="" dir="rtl">حال بعد از این تعریف برای بروزرسانی
کردن می توانید 3 مجموعه ی زیر را در نظر بگیرید.        </p>
<p class="" dir="rtl">A={Win[i][j][1] , Win[i][j][2], … ,
Win[i][j][k-1]}</p>
<p class="" dir="rtl">B={Win[i][1][k], Win[i][2][k], … ,
Win[i][j-1][k]}</p>
<p class="" dir="rtl">C={Win[i-1][a[i]][j],
Win[i-1][a[i]][k]}</p>
<p align="right" class="" dir="ltr">حال اگر همه ی اعضای A ,B, C یک بود،Win[i][j][k]=0ودر غیر این صورت یک. (چرا؟). </p>
<p class="" dir="rtl">نکته : با استفاده از ارایه ی
کمکی زمان الگوریتم را بهO(n^3)قابل کاهش است.</p>
<p class="" dir="rtl"><a href="http://paste.ubuntu.com/821742/">کد سوال</a></p>
<p class="" dir="rtl"> </p>
<p class="" dir="rtl">3-   3- ابتدا تعاریف زیر را در نظر بگیرید :</p>
<p class="" dir="rtl">تورنمنت : به هر گراف جهت داری که بین
هر دو راسش دقیقا یک یال جهت دار باشد ، می گوییم.</p>
<p class="" dir="rtl">پادشاه : در گراف جهت دار به راس هایی
که به تمامی راس های دیگر با فاصله حداکثر دو مسیر دارند ، پادشاه می گوییم.</p>
<p class="" dir="rtl">لم : هر تورنمنت حداقل یک پادشاه
دارد.</p>
<p class="" dir="rtl">اثبات : ثابت می کنیم در یک تورنمت
راس با درجه ی خروجی بیشینه پادشاه است. راسvرا راس با این خاصیت در نظر بگیرید. حال سایر راس ها را به دو
دسته یAوBتقسیم کنید که دسته یAراس هایی هستند
که از راسvبه آنها یال وارد شده است
و دسته یBراس هایی که از آنها بهvیال وارد شده است. واضح است که چون گرافمان تورنمنت است هر راس جزvیا درAاست یا درB. حال یک راس ازBمانندuرا در نظر بگیرید. اگر راسی مثلwوجود داشت که  (w-&gt;u)پس مسیر(v-&gt;w-&gt;u)یک
مسیر به طول دو ازvبهuاست. اگر هیچ راسی مثلwنباشد در این
صورت یعنیu به همه ی اعضایAیال خروجی داشته است و چون یال(u-&gt;v)را هم داریم پس
درجه ی خروجیuحداقل یکی بیشتر ازvاست که این با فرض ما در تناقض است. پسvبه هر راس ازBمسیری به طول
دو و به هر راس ازAمسیری به طول یک دارد . پس حکم اثبات
شد.</p>
<p class="" dir="rtl">حال به حل مساله ی اصلی می پردازیم.
صورت گرافی مساله می شود:</p>
<p class="" dir="rtl">« در یک تورنمنت تمامی راس هایی را
بیابید که به همه ی راس های دیگر مسیر دارند.»</p>
<p class="" dir="rtl">حال می دانیم که گراف یک پادشاه دارد
آن را پیدا می کنیم. سپس یال های گراف را بر عکس میکنیم و روی آن پادشاه dfsمیزنیم. مجموعه
ی راس هایی که درdfsبه آنها رسیده ایم همان راس های خواسته
شده ی مساله اند (چرا؟).<a href="http://paste.ubuntu.com/821738/"><br/></a></p>
<p class="" dir="rtl"><a href="http://paste.ubuntu.com/821738/">کد سوال</a></p>
<p class="" dir="rtl"><a href="http://paste.ubuntu.com/821738/"><br/></a></p>
<p class="" dir="rtl"></p>
<p class="" dir="rtl">   
  4- برای راحتی کار به مربع های داخل دایره سیاه و به بقیه سفید می
گوییم.</p>
<p class="" dir="rtl">حال ما برای این که تعداد خانه های
سیاه جدول را بشماریم می توانیم تعداد خانه های سیاه هر سطر را حساب کنیم و سپس
حاصل جمع را چاپ  کنیم. اگر بتوانیم تعدد خانه های سیاه هر سطر را درO(n*log(n))حل کنیم با توجه به این کهnسطر داریم پیچیدگی کل مسالهO(n^2*log(n))می شود که همان چیزی است
که مساله می خواهد.</p>
<p class="" dir="rtl">بنابراین از این به بعد روی تعداد
خانه های یک سطر خاص متمرکز می شویم.</p>
<p class="" dir="rtl">دایره یiام را در نظر بگیرید. اگر چپ ترین و راست ترین خانه ی این سطر که
توسط این دایره سیاه شده اند را به ترتیبL[i]  وR[i]بگیریم.(ستون ها را با 1 تاnاز چپ به راست شماره گذاری کنید.) واضح است که
تمامی خانه های بینL[i]وR[i]نیز سیاه می شوند. حال اگر اکنون به هر
دایره بازه ی[L[i],R[i]]را نسبت دهیم باید تعداد اعداد داخل کل
اینnبازه را به دست آوریم.</p>
<p class="" dir="rtl">برای این ، بازه ها را به صورت اجتماع
این بازه ها را ، به صورت چند بازه ی بدون اشتراک حساب می کنیم و سپس اندازه ی
بازه های جدید به دست آمده را با هم جمع می کنیم تا به عدد مطلوب برسیم.</p>
<p class="" dir="rtl">حال برای این که اجتماع اینnبازه را به صورت تعدادی بازه ی بدون اشتراک بنویسیم به صورت زیر
عمل میکنیم:</p>
<p class="" dir="rtl">بازه ها را بر حسب ابتدای شان مرتب
میکنیم. سپس از ابتدا روی بازه ها شروع به حرکت می کنیم. فرض کنید الان روی بازه یiام هستیم و اجتماعi-1بازه ی قبلی به درستی حساب شده اند. حال اگر بازه یiرا در نظر بگیرید این بازه فقط می تواند
روی آخرین بازه ی اجتماعi-1بازه ی اول
تغییر ایجاد کند. در این صورت اگر انتها ی آخرین بازه قبل از شروع بازه یiبود ، اجتماعiبازه ی اول
میشود اجتماعi-1بازه ی اول و بازه یi. در غیر این صورت بازه ی آخر اجتماعi-1بازه را به روز رسانی میکنیم.</p>
<p class="" dir="rtl"><a href="http://paste.ubuntu.com/821573/">کد سوال</a>(در کد برای جلوگیری از پیچیدگی ، مرکز دایره ها روی مراکز مربع ها در نظر گرفته
شده اند.)</p>
<p class="" dir="rtl">  </p>
<p class="" dir="rtl"> </p>
</div>
